<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
	<style type="text/css">
	.auto-style1 {
		margin-left: 40px;
	}
	TD.modesTD{
		width:120px;
	}
	</style>
</head>
<body>
    <div id="nutshell"><h3>In a nutshell</h3>
    <p>TSP ("teaspoon") stands for Typed Server Pages. It is a framework for 
	building web pages. TSP content is built using files containing static HTML5 
	compliant markup as a base, but modified dynamically using 
    JavaScript combined with JSON or other data.&nbsp; But the twist is the same 
	JavaScript code can execute on the server and/or the client.&nbsp; The 
	JavaScript of the supporting TSP framework is compiled from Typescript (hence the "Typed" 
	in the name), and applications built using the TypeScript compiler / IDE 
	tools could benefit from the added type safety. But custom application logic may be written entirely in 
	JavaScript if preferred (or other languages which compile to JavaScript).&nbsp; 
	While JavaScript becomes a primary vehicle for devlivering content both on 
	the client on the server, there is one island of functionality 
	implementation left where a more mature language (from a server point of 
	view) can be used - in generating the data model.&nbsp; </p>  
    
    <p>Standard JavaScript tags (&lt;script&gt;...&lt;/script&gt;) will by default continue to execute on the 
	DOM in the client browser.&nbsp; As such, we would expect it to execute the same regardless of the web server (but may 
	differ based on different browser capabilities / quirks).&nbsp; However, 
	JavaScript tags in the html markup adorned with the custom attribute: </p>
		<p class="auto-style1">&lt;script <strong>data-mode='server-side-only'</strong>&gt;...&lt;/script&gt;</p>
		<p>will, in an environment which supports TSP's, execute the JavaScript 
		contained within the tag 
		on the server.&nbsp; The JavaScript which executes on the server will continue to have 
		limited access to a server-side representation of DOM, as the script will be executed in an environment 
		where the base html has been parsed in a "virtual browser". It is 
		limited in that it will not have access to the brower, window or event 
		objects, which only make sense in a true browser environment.&nbsp; In a a host 
		environment where the custom attribute tags is not recognized by the 
		server-side processor, such as a plain vanilla Apache web server, or a 
		local file server, 
		it would continue to execute on the client, and will likely continue to succeed.&nbsp; 
	The reasons applications may benefit from the ability 
	to execute some or all of the JavaScript on the server side could include:</p>
		<ul>
			<li>Applying sensitive logic, such as data visibility or functional 
			capability tailoring, based on authorization.</li>
			<li>Performance optimizations made possible by filtering data and/or markup on the 
			server before sending to the client.</li>
			<li>Uniformity of JavaScript engine.</li>
			<li>Targeting client devices where the JavaScript engine cannot be 
			guaranted to be very powerful or comply to the latest standards, or 
			where JavaScript might be disabled completely.</li>
		</ul>
    </div>
	<div id="prototyping"><h3>Prototyping</h3>
	The ease with which a developer can finesse in which tier (server vs. 
		client) dynamic logic gets applied means that, with a few minor 
		adjutments, one can turn a high fidelity prototype -- running on a 
		simple out-of-the-box Apache web, or local file server, where all the 
		logic executes in a cutting edge browser of the developer's choosing, 
		using static data -- into a fully functioning production application 
		with real business data, targeting a large assortment of devices.&nbsp; In 
		fact, the migration can be so seamless and non intrusive that development could continue between 
		UI specialists and nitty gritty "engineering" programmers in parallel.&nbsp; 
		Supporting this kind of development is an important guiding principle 
		for this principle</div>
	<div id="modes">
		<h3>Modes</h3>
		<a href="#nutshell">As we've seen</a>, a central custom attribute is introduced in TSP:  data-mode, which can be set, 
		for example, to 'server-side-only'.&nbsp;&nbsp; 
		This attribute is applicable to &lt;script/&gt;, &lt;iframe/&gt;, &lt;form/&gt;, &lt;style/&gt;.&nbsp; 
		The following table lists all the possible values, the meaning, and the 
		default value if the attribute is not specified:<br><br>
		<table style="width: 100%">
			<tr>
				<td>Tag Name</td>
				<td>Possible Values / Meaning</td>
				<td>Default Value if not specified</td>
				<td>Notes</td>
			</tr>
			<tr>
				<td>script</td>
				<td>
				
								<table style="width: 100%">
									<tr>
										<td class="modesTD"><strong>client-side-only</strong></td>
										<td>Standard script - only executes within client browser.</td>
									</tr>
									<tr>
										<td>server-side-only</td>
										<td>Script only executes within "virtual 
										browser" on server.&nbsp; After 
										processing, this virtual 
										browser is then "DOM-serialized" to html, which is 
										sent to client browser.</td>
									</tr>
									<tr>
										<td>both</td>
										<td>Script executes both in the client 
										browser and the virtual browser on 
										server.</td>
									</tr>
				</table>
								</td>
				<td>client-side-only (except in case of Model script tags)</td>
				<td>Some subtleties arise in the case of <a href="#modeling">
				Model script tags</a>.</td>
			</tr>
			<tr>
				<td>iframe</td>
				<td>
				<table style="width: 100%">
					<tr>
						<td class="modesTD"><strong>client-side-only</strong></td>
						<td>Standard iframe, embeds content via client browser child window.</td>
					</tr>
					<tr>
						<td>server-side-only</td>
						<td>Content from referenced page is merged into parent 
						document.</td>
					</tr>
				</table>
				</td>
				<td>client-side-only</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td>form</td>
				<td>
				<table style="width: 100%">
					<tr>
						<td class="modesTD">client-side-only</td>
						<td>On form submit, form fields are set via AJAX request to server, 
						without redrawing the page. HTML returned, which is merged into DOM document</td>
					</tr>
					<tr>
						<td><strong>server-side-only</strong></td>
						<td>Standard form.&nbsp; On submit, form fields are sent 
						to server, which processes the user inputs, and page is 
						replaced by a new page.</td>
					</tr>
				</table>
				</td>
				<td>server-side-only</td>
				<td>&nbsp;</td>
			</tr>
		</table>
		
		In the case of the style attribute, if the custom attribute data-js-compiler is set, then the style attribute will be compiled into javascript, 
		and the data-mode attribute then becomes applicable, taking on the same meaning and default as for the script tag.  For example, 
		as discussed in more detail later, the example below:
	
<br>&nbsp;		

<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="32" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">style</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-mode</span><span style="background:#ffffff;color:#0000ff">=&quot;client-side-only&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">type</span><span style="background:#ffffff;color:#0000ff">=&quot;text/css&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-js-compiler</span><span style="background:#ffffff;color:#0000ff">=&quot;tsp.script-rules&quot;&gt;    </span></li>
<li style="background: #f3f3f3">    <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#800000">#myTable{</span></li>
<li>        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#ff0000">call</span><span style="background:#ffffff;color:#000000">:               </span><span style="background:#ffffff;color:#0000ff">tsp.fillGrid</span><span style="background:#ffffff;color:#000000">;</span></li>
<li style="background: #f3f3f3">        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#ff0000">tsp-getDataTable</span><span style="background:#ffffff;color:#000000">:   </span><span style="background:#ffffff;color:#0000ff">()</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#0000ff">=&gt;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#0000ff">model.dataTable</span><span style="background:#ffffff;color:#000000">;</span></li>
<li>        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#ff0000">tsp-rowSelection</span><span style="background:#ffffff;color:#000000">:   </span><span style="background:#ffffff;color:#0000ff">tsp.SelectionOptions.single</span><span style="background:#ffffff;color:#000000">;</span></li>
<li style="background: #f3f3f3">        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#ff0000">tsp-titleFill</span><span style="background:#ffffff;color:#000000">:      </span><span style="background:#ffffff;color:#0000ff">tsp.TitleFillOptions.text</span><span style="background:#ffffff;color:#000000">;</span></li>
<li>   <span style="background:#ffffff;color:#000000">}</span></li>
<li style="background: #f3f3f3"><span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">style</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>
	
<br>will be compiled on the server side into:<br><br>


<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="41" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-mode</span><span style="background:#ffffff;color:#0000ff">=&quot;client-side-only&quot;&gt;</span></li>
<li style="background: #f3f3f3">        <span style="background:#ffffff;color:#000000">tsp._if(</span><span style="background:#ffffff;color:#a31515">&#39;#myTable&#39;</span><span style="background:#ffffff;color:#000000">, {</span></li>
<li>            <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#a31515">&#39;call&#39;</span><span style="background:#ffffff;color:#000000">: tsp.fillGrid,</span></li>
<li style="background: #f3f3f3">            <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#a31515">&#39;tsp-getDataTable&#39;</span><span style="background:#ffffff;color:#000000">: </span><span style="background:#ffffff;color:#0000ff">function</span><span style="background:#ffffff;color:#000000"> () { </span><span style="background:#ffffff;color:#0000ff">return</span><span style="background:#ffffff;color:#000000"> model.dataTable; },</span></li>
<li>            <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#a31515">&#39;tsp-rowSelection&#39;</span><span style="background:#ffffff;color:#000000">: tsp.SelectionOptions.single,</span></li>
<li style="background: #f3f3f3">            <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#a31515">&#39;tsp-titleFill&#39;</span><span style="background:#ffffff;color:#000000">: tsp.TitleFillOptions.text,</span></li>
<li>        <span style="background:#ffffff;color:#000000">});</span></li>
<li style="background: #f3f3f3"><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>

		 		
		<br>

		 		
	</div>
	<div id="modeling">
	<h3>Modeling</h3>
	
	The TSP container provides a way to embed dynamic JSON data, as a branch in the global 'model' object.
	
	
		<br><br><br>

<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="8" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-model</span><span style="background:#ffffff;color:#0000ff">=&quot;[TestWebAppClassic.ProductManager, TestWebAppClassic].RetrieveProduct&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-mode</span><span style="background:#ffffff;color:#0000ff">=&quot;both&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">id</span><span style="background:#ffffff;color:#0000ff">=&quot;product&quot;
<span style="background:#ffffff;color:#ff0000">async</span>&gt;</span></li>
<li style="background: #f3f3f3">        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">var</span><span style="background:#ffffff;color:#000000"> model = {};</span></li>
<li>        <span style="background:#ffffff;color:#000000">model.product = { Name: </span><span style="background:#ffffff;color:#a31515">
"Ipsum Lorem"</span><span style="background:#ffffff;color:#000000"> };</span></li>
<li style="background: #f3f3f3"><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>
	
	
	</div>
	<p>&nbsp;</p>
	<p>The JavaScript code inside the script tag will in this case be discarded 
	on the server side during run time in the context of a functioning TSP 
	container.&nbsp; The dummy data is there for two purposes -- it allows 
	prototyping in a simple file server enviornment to provide a rudimentary 
	representation of how it will look with actual data. Secondly, if the 
	developer tests out some JavaScript&nbsp; by directly embedded it in the 
	page, then references to the model will benefit from intellisense, and 
	rudimentary inconsistency checks, at least in sophisticated enough IDE's.</p>
	<p>The key new attribute here is the <span style="background:#ffffff;color:#ff0000">data-model</span> 
	attribute.&nbsp; Constructin the model data / structure is the one place 
	where the application logic we can move utlize platforms other than a 
	JavaScript runtime, if we wish.&nbsp; The attribute specifies a static 
	method in a static class.&nbsp; This method may be defined in one of two 
	languages:&nbsp; JavaScript, or in whatever specific implementation of the 
	TSP framework is running.&nbsp; The example above wraps the class identifier 
	in brackets, which signifies to look for a class in a .net assembly (for the 
	.net based implementation of TSP).&nbsp; No brackets would indicate to use a 
	JavaScript call (made on the server side, regardless of the data-mode 
	attribute).&nbsp; The returned object from this static method is serialized 
	into JSON by the TSP Container. The static method can access the http 
	context object to gain access to any query string parameters, cookies, etc.</p>
	<p>Like other script tags, the ones which contain the data-model attribute 
	also support the data-mode attribute, but its meaning is a bit different 
	here.&nbsp; Regardless of the value of data-mode, the data model will be 
	generated by the server, and will wipe away the content inside the script 
	tag.&nbsp; The only questions are whether 1) the data model needs to be 
	downloaded to the client and 2) if so, whether the download should be part 
	of the payload of the original page, or instead should be downloaded 
	separately from the page via a call-back ajax call.&nbsp; This is sorted out 
	as follows:</p>
	<ul>
		<li>If attribute <em>data-mode</em> is 'server-side-only', then the data 
		will be retrieved, and the data will be added to the model, <em>prior</em> 
		to the processing of the other server-side javascript tags.&nbsp; 
		However, the data will be excluded from the output sent to the client.</li>
		<li>If attribute <em>data-mode</em> is 'both' (the default in this 
		special script tag case), this will do the same as the serer-side-only 
		setting mentioned above, but it will transmit the the data to the 
		client. If the HTML5 attribute 'async' is set for the script tag, 
		however, the data which was retrieved for purposes of server side 
		processing will be briefly cached, and instead of embedding the data in 
		the main page payload, the client will make an ajax request to retrieve 
		the data and merge it into the global object<em> model </em>(and in 
		supported browsers, the async flag will allow other processing to 
		continue while waiting.</li>
		<li>If attribute <em>data-mode</em> is 'client-side-only', the data will 
		still ultimately be retrieved by the server.&nbsp; However, the act of 
		retrieving the data will happen much later, and will not be made until 
		the page is rendered by the client, which will then generate an AJAX 
		request.&nbsp; The AJAX request will go to the server, which will still 
		call the static method specified by the data-model attribute and pass 
		the JSON serialized back to the client, which will merge the data into 
		the global <em>model </em>object.</li>
	</ul>
	<p>When data is retrieved asynchronously on the client, it will be up to the 
	developer to ensure that any elements of the page which depend on this data, 
	should get (re)evaluated following the retrieval of the data.&nbsp; The TSP 
	framework will provide some support for such scenarios.</p>
	<p>&nbsp;</p>
	
	<div id="server-side-script">
	<h3>Server side script tags</h3>
	<h4>Implementation</h4>
	
		<p>Central to the TSP Framework is the concept of a "virtual browser" 
		running in the server.&nbsp; This concept is a simple extension of the 
		idea behind node.js and other server-side solutions which 
		provide a wrapper around the Google Chrome V8 engine.  But while those solutions
		 </p>
	</div>
</body>
</html>
