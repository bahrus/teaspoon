<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title> Specification</title>
	<style type="text/css">
	.auto-style1 {
		margin-left: 40px;
	}
	TD.modesTD{
		width:120px;
	}
	    .auto-style2 {
            width: 100%;
        }
	    .auto-style4 {
            width: 178px;
        }
	</style>
	<title>
	Typed Server Pages, a Dual Browser Framework
	</title>
</head>
<body style="width:800px">
<h2>The Dual Browser Specification, version 1.0</h2>
    <div id="nutshell"><h3>In a nutshell</h3>
    <p>Many recent innovations in the area of web development have been client-side frameworks based on JavaScript, such as JQuery based frameworks, or AngularJS.&nbsp; These frameworks have largely&nbsp;shunted the benefits which might derive from synergies with server-side processing.&nbsp; The role of the server has, in many cases, been reduced to providing dumb static file server capabilities, in conjunction with providing live JSON data feeds.</p>
        <p>The "Dual Browser Specification" (DBS) is a set of HTML attributes, which provide a light-weight synergy between the server and a JavaScript-heavy client application, for 
	building web pages. DBS content is built using files containing static HTML5-compliant 
	markup as a base, but modified dynamically using 
    JavaScript, combined with data in JSON or other formats.&nbsp; But the twist with DBS is that the same 
	JavaScript code can usually execute on the server and/or the client, and produce identical results.&nbsp; 
	
		</p>
		<p>Typed Server Pages (TSP) is the first implementation of the DBS.&nbsp; TSP is implemented as an ASP.net http handler.&nbsp; TSP also builds on the DBS, providing a JavaScript library, which adds some useful functionality on top of the base DBS.&nbsp; The 
	JavaScript of the supporting TSP implentation is compiled from Typescript (hence the "Typed" 
	in the name), and applications built using the TypeScript compiler / IDE 
	tools could benefit from the added type safety when integrating with the API. But custom application logic may be written directly in 
	JavaScript if preferred (or other languages which compile to JavaScript).&nbsp; The TypeScript/JavaScript libraries which come with TSP can also be leveraged in other future DBS implementation, built leveraging the Java or node.JS platforms, for example.</p>
		<p>While JavaScript becomes a primary vehicle for delivering content both on the client on the server in the Dual Browser container, there are a few islands of functionality 
	where a more mature language (from a server point of 
	view) can be used - for example, in generating the data model, and in providing support for compiling tags in one form into another..&nbsp; </p>  
    
    <p>Standard JavaScript tags (&lt;script&gt;...&lt;/script&gt;) will by default continue to execute on the 
	DOM in the client browser.&nbsp; As such, we would expect it to execute the same regardless of the web server (but results may vary, unfortunately, 
	based on different browser capabilities / quirks).&nbsp; However, 
	JavaScript tags in the html markup adorned with the custom attribute: </p>
		<p class="auto-style1">&lt;script <strong>data-mode='server-side-only'</strong>&gt;...&lt;/script&gt;</p>
		<p>will, in an environment which supports the DBS, execute the JavaScript 
		contained within the tag 
		<em>on the server</em>.&nbsp; The JavaScript which executes on the server will continue to have 
		limited access to a server-side representation of DOM, as the script will be executed in an environment 
		where the base html has been parsed in a "virtual browser". It is 
		limited in that it will not have access to the brower, window or event 
		objects, which only make sense in a true browser environment.&nbsp; In a host 
		environment where the custom attribute tags is not recognized by the 
		server-side processor, such as a plain vanilla Apache web server, or a 
		local file server, 
		it would continue to execute on the client, and will likely continue to succeed.&nbsp; 
	The reasons applications may benefit from the ability 
	to execute some or all of the JavaScript on the server side could include:</p>
		<ul>
			<li>Applying sensitive logic, such as data visibility or functional 
			capability tailoring, based on authorization.</li>
			<li>Performance optimizations made possible by filtering data and/or markup on the 
			server before sending to the client.</li>
			<li>Uniformity of JavaScript engine allows the same validation business logic, for example, to execute both in the client for quicker feedback, and the server, for fail-safe validation.</li>
			<li>Targeting client devices where the JavaScript engine cannot be 
			guaranted to be very powerful or comply to the latest standards, or 
			where JavaScript might be disabled completely (such as Lync).</li>
		</ul>
    </div>
	<div id="prototyping"><h3>Prototyping</h3>
	The ease with which a developer can finesse in which tier (server vs. 
		client) dynamic logic gets applied means that, with a few minor 
		adjutments, one can turn a high fidelity prototype -- running on a 
		simple out-of-the-box web server, or even a local file server, where all the 
		logic executes in a browser of the developer's choosing, 
		using static data -- into a fully functioning production application 
		with real business data, targeting a large assortment of devices.&nbsp; In 
		fact, the migration can be so seamless and non intrusive that development could continue between 
		UI specialists and nitty gritty "engineering" programmers in parallel.&nbsp; 
		Supporting this kind of development pattern is an important guiding principle for this specification.</div>
	<div id="modes">
		<h3>Modes</h3>
		<a href="#nutshell">As we've seen</a>, a central custom attribute is introduced in DBS:  <em>data-mode</em>, which can be set, 
		for example, to 'server-side-only'.&nbsp;&nbsp; 
		This attribute is applicable to &lt;script/&gt;, &lt;iframe/&gt;, &lt;form/&gt;, &lt;style/&gt;.&nbsp; 
		The following table lists all the possible values, the meaning, and the 
		default value if the attribute is not specified:<br><br>
		<table style="width: 100%">
			<tr>
				<td>Tag Name</td>
				<td>Possible Values / Meaning</td>
				<td>Default Value if not specified</td>
				<td>Notes</td>
			</tr>
			<tr>
				<td>script</td>
				<td>
				
								<table style="width: 100%">
									<tr>
										<td class="modesTD"><strong>client-side-only</strong></td>
										<td>Standard script - only executes within client browser.</td>
									</tr>
									<tr>
										<td>server-side-only</td>
										<td>Script only executes within a "virtual 
										browser" on server.&nbsp; After 
										processing, this virtual 
										browser is then "DOM-serialized" to html, which is 
										sent to client browser.</td>
									</tr>
									<tr>
										<td>both</td>
										<td>Script executes both in the client 
										browser and the virtual browser on 
										server.</td>
									</tr>
                                    <tr>
                                        <td>depends</td>
                                        <td>
                                            Custom logic can be used to determine in which tier the code should execute.  
                                            The custom attribute data-dynamic-mode will call a server side function / method, which will return
                                            one of the other three values.
                                        </td>
                                    </tr>
				</table>
								</td>
				<td>client-side-only (except in case of Model script tags)</td>
				<td>Some subtleties arise in the case of <a href="#modeling">
				Model script tags</a>.</td>
			</tr>
			<tr>
				<td>iframe</td>
				<td>
				<table style="width: 100%">
					<tr>
						<td class="modesTD"><strong>client-side-only</strong></td>
						<td>Standard iframe, embeds content via client browser child window.</td>
					</tr>
					<tr>
						<td>server-side-only</td>
						<td>Content from referenced page is merged into parent 
						document.</td>
					</tr>
                    <tr>
                        <td>depends</td>
                        <td>
                            Custom logic can be used to determine in which tier the code should execute.  
                            The custom attribute data-dynamic-mode will call a server side function / method, which will return
                            one of the other three values.
                        </td>
                    </tr>
				</table>
				</td>
				<td>client-side-only</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td>form</td>
				<td>
				<table style="width: 100%">
					<tr>
						<td class="modesTD">client-side-only</td>
						<td>On form submit, form fields are set via AJAX request to server, 
						without redrawing the page. HTML markup is returned, which is merged into DOM document</td>
					</tr>
					<tr>
						<td><strong>server-side-only</strong></td>
						<td>Standard form.&nbsp; On submit, form fields are sent 
						to server, which processes the user inputs, and page is 
						replaced by a new page (barring specification of target).</td>
					</tr>
				</table>
				</td>
				<td>server-side-only</td>
				<td>&nbsp;</td>
			</tr>
		</table>
		
		In the case of the style attribute, if the custom attribute <em>data-compiler</em> is set, then the style attribute will be compiled into javascript, 
		and the <em>data-mode</em> attribute then becomes applicable, taking on the same meaning and default as for the script tag.  For example, 
		as discussed in the TSP implementation document:
	
<br>&nbsp;		

<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="32" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">style</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-mode</span><span style="background:#ffffff;color:#0000ff">=&quot;client-side-only&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">type</span><span style="background:#ffffff;color:#0000ff">=&quot;text/css&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-js-compiler</span><span style="background:#ffffff;color:#0000ff">=&quot;tsp.script-rules&quot;&gt;    </span></li>
<li style="background: #f3f3f3">    <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#800000">#myTable{</span></li>
<li>        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#ff0000">call</span><span style="background:#ffffff;color:#000000">:               </span><span style="background:#ffffff;color:#0000ff">tsp.fillGrid</span><span style="background:#ffffff;color:#000000">;</span></li>
<li style="background: #f3f3f3">        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#ff0000">tsp-getDataTable</span><span style="background:#ffffff;color:#000000">:   </span><span style="background:#ffffff;color:#0000ff">()</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#0000ff">=&gt;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#0000ff">model.dataTable</span><span style="background:#ffffff;color:#000000">;</span></li>
<li>        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#ff0000">tsp-rowSelection</span><span style="background:#ffffff;color:#000000">:   </span><span style="background:#ffffff;color:#0000ff">tsp.SelectionOptions.single</span><span style="background:#ffffff;color:#000000">;</span></li>
<li style="background: #f3f3f3">        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#ff0000">tsp-titleFill</span><span style="background:#ffffff;color:#000000">:      </span><span style="background:#ffffff;color:#0000ff">tsp.TitleFillOptions.text</span><span style="background:#ffffff;color:#000000">;</span></li>
<li>   <span style="background:#ffffff;color:#000000">}</span></li>
<li style="background: #f3f3f3"><span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">style</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>
	
<br>will be compiled on the server side into:<br><br>


<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="41" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-mode</span><span style="background:#ffffff;color:#0000ff">=&quot;client-side-only&quot;&gt;</span></li>
<li style="background: #f3f3f3">        <span style="background:#ffffff;color:#000000">tsp._if(</span><span style="background:#ffffff;color:#a31515">&#39;#myTable&#39;</span><span style="background:#ffffff;color:#000000">, {</span></li>
<li>            <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#a31515">&#39;call&#39;</span><span style="background:#ffffff;color:#000000">: tsp.fillGrid,</span></li>
<li style="background: #f3f3f3">            <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#a31515">&#39;tsp-getDataTable&#39;</span><span style="background:#ffffff;color:#000000">: </span><span style="background:#ffffff;color:#0000ff">function</span><span style="background:#ffffff;color:#000000"> () { </span><span style="background:#ffffff;color:#0000ff">return</span><span style="background:#ffffff;color:#000000"> model.dataTable; },</span></li>
<li>            <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#a31515">&#39;tsp-rowSelection&#39;</span><span style="background:#ffffff;color:#000000">: tsp.SelectionOptions.single,</span></li>
<li style="background: #f3f3f3">            <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#a31515">&#39;tsp-titleFill&#39;</span><span style="background:#ffffff;color:#000000">: tsp.TitleFillOptions.text,</span></li>
<li>        <span style="background:#ffffff;color:#000000">});</span></li>
<li style="background: #f3f3f3"><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>

		 		
		<br>

		 		
	</div>
	<div id="modeling">
	<h3>Modeling</h3>
	
	The DBS provides a way to embed dynamic JSON data, as a branch in the global 'model' object.
	
	
		<br><br><br>

<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="8" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-model</span><span style="background:#ffffff;color:#0000ff">=&quot;[TestWebAppClassic.ProductManager, TestWebAppClassic].RetrieveProduct&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-mode</span><span style="background:#ffffff;color:#0000ff">=&quot;both&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">id</span><span style="background:#ffffff;color:#0000ff">=&quot;product&quot;
<span style="background:#ffffff;color:#ff0000">async</span>&gt;</span></li>
<li style="background: #f3f3f3">        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">var</span><span style="background:#ffffff;color:#000000"> model = {};</span></li>
<li>        <span style="background:#ffffff;color:#000000">model.product = { Name: </span><span style="background:#ffffff;color:#a31515">
"Ipsum Lorem"</span><span style="background:#ffffff;color:#000000"> };</span></li>
<li style="background: #f3f3f3"><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>
	
	
	
	<p>&nbsp;</p>
	<p>The JavaScript code inside this kind of modeling script tag will be discarded on the server side during run time in the context of a functioning DBS container.&nbsp; The dummy data is there for two purposes -- it allows prototyping in a simple file server enviornment to provide a rudimentary representation of how it will look with actual data. Secondly, if the developer tests out some JavaScript&nbsp; by directly embedding it in the 
	page, then references to the model will benefit from intellisense, and 
	    basic inconsistency checks, at least in sophisticated enough IDE's.&nbsp; There is a small performance hit from including dummy data inside the script tag - the server will spend slightly more time parsing the dom file, longer if the dummy data is extraordinarily large.</p>
	<p>The key new attribute here is the <span style="background:#ffffff;color:#ff0000">data-model</span> attribute.&nbsp; Constructing the model (or &quot;view model&quot;) data structure is one place in the application logic where we can utlize platforms other than a JavaScript runtime, if we wish.&nbsp; The attribute specifies a static method in a static class.&nbsp; This method may be defined in one of two language runtimes:&nbsp; i) JavaScript, or ii) in whatever specific platform the implementation of the DBS framework is running.&nbsp; This string identifier for a server-side method will be referred to as the &quot;server-side method string&quot;.&nbsp; The example above wraps the class identifier 
	in brackets, which signifies to look for a class in a .net assembly (for the 
	.net based implementation of TSP).&nbsp; No brackets would indicate to use a 
	JavaScript call, where the JavaScript method is either embedded in the page, or exists in a referenced JS file.&nbsp; Even if JavaScript is chosen, it will be called on the server side, regardless of the data-mode 
	attribute.&nbsp; The returned object from this static method is serialized 
	into JSON by the TSP Container, and added to the global &#39;model&#39; object, keyed according to the id of the script tag (&#39;product&#39; in the example above). The static method can access the http 
	context object to gain access to any query string parameters, cookies, etc.</p>
	<p>Like other script tags, the ones which contain the <em>data-model </em>attribute 
	also support the <em>data-mode</em> attribute, but its meaning is a bit different 
	here.&nbsp; Regardless of the value of data-mode, the data model will be 
	generated by the server, and will wipe away the content inside the script 
	tag.&nbsp; The only questions are whether 1) the data model JSON needs to be 
	downloaded to the client and 2) if so, whether the download should be part 
	of the payload of the original page, or instead should be downloaded 
	separately from the page via a call-back ajax call.&nbsp; This is sorted out 
	as follows:</p>
	<ul>
		<li>If attribute <em>data-mode</em> is 'server-side-only', then the data 
		will be retrieved, and the data will be added to the model, <em>prior</em> 
		to the processing of the other server-side javascript tags.&nbsp; 
		However, the data will be excluded from the output sent to the client.</li>
		<li>If attribute <em>data-mode</em> is 'both' (the default in this 
		special script tag case), this will do the same as the serer-side-only 
		setting mentioned above, but it will transmit the data to the 
		client. If the HTML5 attribute 'async' is set for the script tag, 
		however, the data which was retrieved for purposes of server side 
		processing will be briefly cached, and instead of embedding the data in 
		the main page payload, the client will make an ajax request to retrieve 
		the data and merge it into the global object<em> model </em>(and in supported browsers, the async flag will allow other processing to continue while waiting).&nbsp; This complex sequence of events will be managed by the DBS container.&nbsp; One other attribute comes into play when data-mode is &#39;both&#39;:&nbsp; The <em>data-csFilter</em> attribute.&nbsp; The value of such an attribute is also expected to be in the form of a server-side method string, and applies further filtering of the object derived from the data-model attribute.&nbsp; This allows the server-side processing to have access to a large object containing potentially sensitive information, but to whittle down the object to a subset which is relevant and public enough that it is appropriate to send this subset down to the client.</li>
		<li>If attribute <em>data-mode</em> is 'client-side-only', the data will 
		still ultimately be retrieved by the server.&nbsp; However, the act of 
		retrieving the data will happen much later, and will not be made until 
		the page is rendered by the client, which will then generate an AJAX 
		request.&nbsp; The AJAX request will go to the server, which will still 
		call the static method specified by the data-model attribute and pass 
		the JSON serialized back to the client, which will merge the data into 
		the global <em>model </em>object.&nbsp; Again, this complex sequence will be managed by the DBS container behind the scenes.</li>
        <li>If attribute <em>data-mode</em> is not specified, it will default to &#39;both&#39;.</li>
	</ul>
	<p>When data is retrieved asynchronously on the client, it will be up to the developer to ensure that any elements of the page which depend on this data, should get (re)evaluated following the retrieval of the data.&nbsp; Making this easier for the developer is an area specific implementations of the DBS may add value.&nbsp; The TSP framework implementation provides support for some such scenarios.</p>
	<p>A special reserved model can be added to the page, as follows:</p>
        

<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="18" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-model</span><span style="background:#ffffff;color:#0000ff">=&quot;[Http].GetContext&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">id</span><span style="background:#ffffff;color:#0000ff">=&quot;myContext&quot;&gt;</span></li>
<li style="background: #f3f3f3">&nbsp;<span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>


        This 
    
	    special model will be provided by the DBS container, and it will generate a JSON representation of the basic request object (query string parameters, cookies, etc) in the following form:<br />
        <br />
        Just as with standard model script tags, this special http context model can contain sample mockup inside the script for intellisense / prototyping purposes, and additionally&nbsp; the <em>data-mode </em> attribute will follow the 
        same standard rules for script model tags, and the <em>data-csFilter</em> will also be honored as before.
        <br /><br />
        Other objects often associated with a web session, such as session objects or application cache, need to be exposed to the browser via 
	    custom model tags.

	</div>
	<div id="server-side-script">
	<h3>Server side script tags</h3>
	<h4>Implementation</h4>
	
		<p>Central to DBS is the concept of a &quot;virtual browser&quot; running in the server.&nbsp; This concept is a simple extension of the idea behind node.js and other server-side solutions which provide a wrapper around the Google Chrome V8 engine. But while those solutions can execute JavaScript, they do not emulate other critical aspects of what happens in a browser, starting with a DOM parser which can read a HTML compliant document, and query and manipulate the document using calls such as document.getElementById, or document.querySelectorAll, or node.appendChild.&nbsp; The following table provides a &quot;shopping list&quot; of functionality needed to implement a virtual browser with enough features to support the DBS.</p>

        <table class="auto-style2">
            <thead>
                <tr>
                    <th colspan="2">Virtual Browser Shopping List</th>
                </tr>
                <tr>
                    <th style="width:200px">Functionality</th>
                    <th>Explanation</th>
                </tr>
            </thead>
            <tr>
                <td>JavaScript Engine</td>
                <td>Ideally should have optimal performance, and be compatible with the JavaScript engine availalbe in modern browsers, 
                    so that the same code can work both on the server as well as the client.

                </td>
            </tr>
            <tr>
                <td>HTML Parser to DOM Tree</td>
                <td>Generally needs to be a bit more sophisticated than a simple xml parser, because HTML5 has more nuances than xml - 
                    it needs to support tags with no closing tag, such as the br tag, for example.  Ideally, it would be as tolerant of malformed html as the major browsers are 
                    (and interpret such non compliance in a similar way) </td>
            </tr>
            <tr>
                <td>DOM API (HTML 4)</td>
                <td>The DOM tree needs to support the equivalent of many of the DOM methods available to HTML 4 browsers, including document.getElementById, document.getElementsByTagName, node.removeChild, etc.&nbsp; However, the method names may be called something different, in which case a Facade, mentioned below, is required.</td>
            </tr>
            <tr>
                <td>DOM API (HTML 5)</td>
                <td>The DOM tree needs to support newer methods including document.querySelectorAll.&nbsp; Again, the names may not match the JavaScript DOM Api specification exactly, in which case a Facade is needed.</td>
            </tr>
            <tr>
                <td>DOM API Facade</td>
                <td>Some DOM Parsers / Tree libraries may support the heavy-lifting functionality needed for the DOM API which JavaScript needs, but the method names may not perfectly match what JavaScript expects in the context of a browser.&nbsp; For example, getElementById might be called GetElementByID.&nbsp; A layer on top of the native api may then need to be built to provide seemless integration with JavaScript.</td>
            </tr>
            
            <tr>
                <td>JQuery Facade</td>
                <td>Being that a significant portion of modern JavaScript manipulation of DOM is done with JQuery, ideally, a significant subset of the JQuery api should work when manipulating the DOM Tree. </td>
            </tr>
            
        </table>

        <br />

        While this dual browser model can allow for much code reuse between the client and server (or code shifting as the needs warrant), we hasten to caution that there are two significant areas of functionality where maintaining an exact replica between the server-side browser, and the client-side browser, is not easy or natural to achieve&nbsp; 1)&nbsp; Event handling, such as the onmousemove event, makes sense on the client, but supporting such event handling on the server side would be contrived and likely to cause more harm than good in terms of performance.&nbsp; The DBS will provide for lighter-weight, more basic approaches for coordinating events between the client and server.&nbsp; 2)&nbsp; The DOM Tree sits in memory in the client browser for the duration of having the page loaded.&nbsp; It is tempting to consider maintaining a shadow copy of the DOM Tree in memory on the server for each user / loaded page as well, and having some process in place to keep them in sync.&nbsp; But that 
        is not the approach recommended by the DBS.&nbsp; While specific implementations of the DBS may take advantage of caching on the server, which may resemble such a solution to a certain degree, the assumption of the DBS is that the server will utilize mostly stateless approaches as a base, and DBS will specify approaches which will work well with this approach.<br />
        <br />

        As an example the TSP implementation of the DBS mixes the following components to achieve the virtual browser.  
        Aternative options are mentioned also.<br />
        <br />
        <table>
            <thead>
                <tr>
                    <th>Functionality</th>
                    <th class="auto-style4">Library</th>
                    <th>Alternatives</th>
                </tr>
            </thead>
            <tr>
                <td>JavaScript Engine</td>
                <td class="auto-style4"><a href="http://javascriptdotnet.codeplex.com/">Javascipt .NET</a></td>
                <td>
                    <ul>
                        <li><a href="https://github.com/Taritsyn/MsieJavaScriptEngine">MsieJavaScriptEngine (Chakra)</a></li>
                        <li><a href="http://v8dotnet.codeplex.com/">V8.NET</a></li>
                                    

                    </ul>

                </td>
            </tr>
            <tr>
                <td>HTML Parser to DOM Tree</td>
                <td class="auto-style4"><a href="http://htmlagilitypack.codeplex.com/">Html Agility Pack</a></td>
                <td>
                    <ul>
                        <li>
                            <a href="http://www.codeproject.com/Articles/609053/AngleSharp">AngleSharp</a>
                        </li>
                        <li>
                            <a href="https://github.com/jamietre/csquery">CSQuery</a>
                        </li>
                        <li>
                            <a href="http://www.geekonweb.com/86/jsoup-a-better-html-parser-than-htmlagilitypack">Jsoup</a>
                        </li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>DOM API (HTML 4)</td>
                <td class="auto-style4"><a href="http://htmlagilitypack.codeplex.com/">Html Agility Pack</a></td>
                <td>&nbsp;</td>
            </tr>
            <tr>
                <td>DOM API (HTML 5)</td>
                <td><a href="https://code.google.com/p/fizzler/">Fizzler</a></td>
                <td>
                    <ul>
                        <li>
                            <a href="https://github.com/jamietre/csquery">CSQuery</a>
                        </li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>DOM API Facade</td>
                <td>tspHandler.HtmlDocumentFacade</td>
            </tr>
            <tr>
                <td>JQuery Facade</td>
                <td>tspHandler.JQueryFacade</td>
            </tr>        
        </table>

        Because some aspects of JavaScript make no sense in the context of a server-side virtual browser, such as event handling in raw html or animations using JQuery, only a subset of the common JavaScript api&#39;s are required to be a compliant DBS container.</div>
    <div id="helloWorldExample">
    <p style="font-weight: 700">
        Example 1:&nbsp; Hello world</p>
    <p>
        Let us now look at the simplest example which demonstrates the dual browser markup in action:</p>
    <p>
        Consider the following markup:</p>
    <p>
        
<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="1" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;!</span><span style="background:#ffffff;color:#800000">DOCTYPE</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">html</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li style="background: #f3f3f3"><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">html</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">xmlns</span><span style="background:#ffffff;color:#0000ff">=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span></li>
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">head</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li style="background: #f3f3f3">    <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">title</span><span style="background:#ffffff;color:#0000ff">&gt;&lt;/</span><span style="background:#ffffff;color:#800000">title</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li>    <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-mode</span><span style="background:#ffffff;color:#0000ff">=&quot;server-side-only&quot;&gt;</span></li>
<li style="background: #f3f3f3">        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">var</span><span style="background:#ffffff;color:#000000"> pss = document.getElementById(</span><span style="background:#ffffff;color:#a31515">&#39;populateServerSide&#39;</span><span style="background:#ffffff;color:#000000">);</span></li>
<li>        <span style="background:#ffffff;color:#000000">pss.innerHTML = </span><span style="background:#ffffff;color:#a31515">&#39;Hello, world, server side&#39;</span><span style="background:#ffffff;color:#000000">;</span></li>
<li style="background: #f3f3f3">    <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">head</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li style="background: #f3f3f3"><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">body</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li>    <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">div</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">id</span><span style="background:#ffffff;color:#0000ff">=&quot;populateClientSide&quot;/&gt;</span></li>
<li style="background: #f3f3f3">    <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">div</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">id</span><span style="background:#ffffff;color:#0000ff">=&quot;populateServerSide&quot;/&gt;</span></li>
<li>    <span style="background:#ffffff;color:#000000"></span></li>
<li style="background: #f3f3f3">    <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li>        <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">var</span><span style="background:#ffffff;color:#000000"> pcs = document.getElementById(</span><span style="background:#ffffff;color:#a31515">&#39;populateClientSide&#39;</span><span style="background:#ffffff;color:#000000">);</span></li>
<li style="background: #f3f3f3">        <span style="background:#ffffff;color:#000000">pcs.innerHTML = </span><span style="background:#ffffff;color:#a31515">&#39;Hello, world, client side&#39;</span><span style="background:#ffffff;color:#000000">;</span></li>
<li>    <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">script</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li style="background: #f3f3f3"><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">body</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">html</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>

    As expected, the page displays two hello statements, but if processed by a DBS container such as TSP, viewing the generated html shows quite a significant difference in how the statements are generated:</p>
    <p>
        <img src="Images/HelloWorld.png" alt="Hello World" />
    </p>
    <p>
        Note that the script with attribute data-mode=&#39;server-side-only&#39; has been removed from the output sent to the client (since it is not needed on the client), and has already executed on the server, so that the div with id populateServerSide is already populated on the server.</p>
    <p>
        This same page, if served by a host which does not understand the DBS markup, would render the same exact display in the browser, but now the markup sent to the client would be identical between the client-side and server-side tags.&nbsp; It is an important design-goal for DBS that, as much as possible, the user not see a difference whether the same script is executed on the server vs. the client.&nbsp; But the observant reader may have spotted that in fact this example would actually fail the test -- in standard browers, the markup as specified would fail, because the script tag in the head is searching for a DOM element that does not yet exist.&nbsp; The virtual browser implemented by TSP does not have this limitation.&nbsp; In this case the entire DOM is first first loaded prior to the execution of the JavaScript.&nbsp; It is debatable whether this difference in behavior should be tolerated.&nbsp; At any rate, the safe thing to do is to place the JavaScript in a location so it will work im all environments. 
        (TODO:&nbsp; JQuery&#39;s ready function)</p>
    <p>
        In many cases we will want to expose common functions both to the server as well as the client.&nbsp; For example, we may have a function that populates a grid, and we may choose to populate the first page on the server side, but populate subsequent pages on the client-side based on a cached data model.&nbsp; That is what the attribute value <em>both </em> for data-mode is there for. But sometimes this common code will need to do slightly diffferent things depending on whether the code is executing on the server or on the client.&nbsp; To determine in what mode the code is running, make use of the DBS reserved global variable <em>mode</em>:</p>
    <p>
        
        
<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="353" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">var</span><span style="background:#ffffff;color:#000000"> isClientMode = (</span><span style="background:#ffffff;color:#0000ff">typeof</span><span style="background:#ffffff;color:#000000"> (mode) == </span><span style="background:#ffffff;color:#a31515">&#39;undefined&#39;</span><span style="background:#ffffff;color:#000000"> || mode !== </span><span style="background:#ffffff;color:#a31515">&#39;server&#39;</span><span style="background:#ffffff;color:#000000">);</span></li>
</ol>
</div>
</div>



    </p>
    </div>
    <div id="iFrame">
	<h3>Server side iFrames</h3>
    <p>
        Most server-side template engines, such PHP or ASP.net, supports some notion of server-side includes, where content from one file can be shared or embedded inside multiple other pages.&nbsp; This is certainly the case with the DBS, but one could argue the solution, consistent with the server-side script tag, is more elegant.&nbsp; Since on the client-side, the tag most often used to embed content from one page into another is the iframe tag, it is natural to extend the same tag to the server side:</p>
        <p>
           
<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="43" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">iframe</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-mode</span><span style="background:#ffffff;color:#0000ff">=&quot;server-side-only&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">src</span><span style="background:#ffffff;color:#0000ff">=&quot;toc_TreeView.tsp.html#treeContainer&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">id</span><span style="background:#ffffff;color:#0000ff">=&quot;toc&quot;&gt;&lt;/</span><span style="background:#ffffff;color:#800000">iframe</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>


        </p>
        <p>
            The page being referenced should consist of a fully-formed html document -- like the script tag, we should
            be able to switch the attribute between client-side-only (regular iframe) and server-side-only -- and get similar (but not identical) results, 
            so the page should, as a matter of best practices, work as a standalone page.
        </p>
        <p>
            But notice the hash tag in the src attribute.&nbsp; This is expected to specify a unique id found in the referenced document.&nbsp; The DBS container will, on the server, remove all content outside the tag matching the id (with some important exceptions mentioned below), and will add the document fragment to the containing DOM document.&nbsp;
        </p>
        <p>
            The DBS document will also merge all script and css references found in the referenced page.&nbsp; It will look for client-side identical refrences to js files or css files, and not duplicate them in the event it finds a matching reference.</p>
        <p>
            Prior to embedding the content of the page the iframe tag references, the usual DBS processing will be executed on the referenced page, most notably execuring any server-side script or nested server-side iframes.</p>
        <p>
            If a DBS document contains multiple server-side iframes linking to the same document, the container will only perform server-side processing once for the duration of the request on this document, and allow different parts of the DOM to be emedded in different locations of the page based on the hash tag identifier.</p>
        <p>
            When emedding the content of a server-side iframe, the DBS container will ensure the uniqueness of the DOM id&#39;s by prepending the id&#39;s with the id of the containing iframe tag separated by an underscore.&nbsp; 
            Styles containing references to these id&#39;s will also be correspondingly namespaced.</p>
        <p>
            &nbsp;</p>
    </div>
    <div id="style">
        <h3>Style directives</h3>
    
    
    JQuery has proven to be a very popular library.&nbsp; Some of this popularity is due to succesfully building on the power of css selectors.&nbsp; However, JQuery is still very much a programming API.&nbsp; While JQuery may tend to encourage &quot;declarative&quot; coding styles, it does not provide a <em>directive</em> based syntax like AngularJS.&nbsp;
        
        <p>
        The distinction between directive-based configuration and declaritive-based programming is somewhat murky, particularly in common parlance.&nbsp; Declarative programming actually has a formal definition - programming without mutable values.&nbsp; But often in casual conversation the term declarative is used when really the more effective term would be directive - e.g. &quot;Hibernate provides a declarative approach to binding to a database&quot; would be more descriptive if &quot;declarative&quot; is replaced with &quot;directive&quot;.&nbsp; For our purposes, we define directives as syntax containing no (or at least very few) method calls (and it should also satisfy the declarative criteria - no mutable values).&nbsp; So, for example, a JSON object, used to configure a client-side datagrid, would be considered a directive element, as pure JSON does not allow for methods.&nbsp; (Typically, however, the JSON concept is extended to allow for syntax involving method calls -- for example, inside event handlers).&nbsp; The more an 
        api relies on such structures to define behavior (as opposed to programmatic method calls), the more we can call it a directive-based API.</p>
        <p>
&nbsp;AngularJS adds custom attributes to DOM elements for its directives.&nbsp; The advantage of this approach is that it is easy to associate the behavior to the element it is getting applied to.&nbsp;&nbsp; This makes sense when binding individual elements to specific places in a data model.&nbsp; But these directives are often extended to be used for many other aspects. The disadvantages of this approach are that 1)&nbsp;&nbsp; these directives will tend to detract from the semantic nature of&nbsp; the html markup and clutter up the page, 2) a large number of directives applied, repetatively, to many elements will tend to increase the bandwidth requirements of the page.&nbsp; These are the problems that JQuery solves quite effectively by applying method calls to all elements satisfying the css selector.&nbsp; But the disadvantage of the JQuery approach is it is difficult to find all the behaviors associated with an element, as the code can be scattered about.</p>
        <p>
        The DBS provides support for a directive-oriented way of associating behavior with elements without the pitfalls of the AngularJS approach:&nbsp; CSS styles which get compiled, on the server, to JavaScript.&nbsp; For example:
    <p>
    
<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="9" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">style</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">type</span><span style="background:#ffffff;color:#0000ff">=&quot;text/css&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-compiler</span><span style="background:#ffffff;color:#0000ff">=&quot;[tspHandler.tspProcessor, tspHandler].attachEvents&quot;&gt;</span></li>
<li style="background: #f3f3f3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#ffffff;color:#800000">input{</span></li>
<li>            <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#ff0000">event</span><span style="background:#ffffff;color:#000000">: </span><span style="background:#ffffff;color:#0000ff">change</span><span style="background:#ffffff;color:#000000">;</span></li>
<li style="background: #f3f3f3">            <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#ff0000">handler</span><span style="background:#ffffff;color:#000000">: </span><span style="background:#ffffff;color:#0000ff">form1.changeHandler</span><span style="background:#ffffff;color:#000000">;        </span></li>
<li>        <span style="background:#ffffff;color:#000000">}</span></li>
<li style="background: #f3f3f3"><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">style</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>
    <br /><br />
    The <em>data-compiler</em> attribute is another example of an attribute expecting a &quot;server-side method&quot; string.&nbsp; 
        The static method will get access to the DOM element containing the style (actually, the parsed CSS rules), 
        and will generate, typically,&nbsp; JavaScript / JSON based on the contents of the tag.&nbsp; 
        It may generate more than one tag.&nbsp; For example, it may generate one script tag consisting of JavaScript, 
        and another style tag which retains those rules which are actually css rules.&nbsp; 
        Or it might be used to compile some compact CSS format (like LESS) into browser-compatible CSS.&nbsp; 
        
        <br /><br />
        The static method, if written in C#, for example, must have signature:
        
        <br /><br />
        The DBS container replaces the original style with these generated tags.The DBS itself does not provide any specific specifications of compilers (at least for version 1.0 of the specification), leaving such implementations entirely to the implementation of the specification, which may provide some handy compilers, or to the application developer.&nbsp; The TSP implementation does provide some highly useful compilers.</p>
    <br /><br />
        The advantages of using style directives like this are:</p>
    <ul>
        <li>Readability:  This ties into a familiar pattern for adding detailed enhancements 
            to elements without cluttering the sematic html.

        </li>
        <li>Succinctness:&nbsp; Like JQuery, a single rule can apply to all elements matching the CSS Selector.&nbsp; But unlike JQuery, further code resuse can be accomplished by taking advantage of the same CSS cascading and specificity rules applied by browsers when applying styles.</li>
        <li>IDE Support:&nbsp; Some IDE&#39;s (e.g. Microsoft Web Expression, Dreamweaver) provide special support for CSS.&nbsp; For example, if you navigate to a DOM element in the HTML Markup, which references a css class name, it may be possible to select the class, and allow the IDE to jump to the CSS rule for the class (at least if there is only one such class definition).&nbsp; This is not available with JQuery code associated with the class.</li>
    </ul>
    <p>
        The disadvantages are:
        <ul>
            <li>Functionality specified this way will not work in a simple web server, but will require a DBS engine to 
                compile the directives on the server.&nbsp; Without such an engine, the directives will be ignored.
            </li>
            <lFunctionality specified this way will not work in a simple web server, but will require a DBS engine to 
                compile the directives on the server.&nbsp; Without such an engine, the directives will be ignored.
            </li>
            <li>IDE&#39;s will generally not recognize links to JavaScript functions. So in the example above, <span style="background:#ffffff;color:#0000ff">form1.changeHandler</span> will 
                not provide any intellisense after typing "form1.", or be able to navigate to the function, or underline in red if the function name has a typo.</li>
            <li>Even for those IDE&#39;s which help maintain the relationship between DOM elements and the classes associated with them, it is less direct than seeing the directives directly in the element itself.&nbsp; Web browsers&#39; developer tools help visualize the relationship even more clearly, but this help may not work with these custom styles [TODO: research].</li>
        </ul>
        </p>
    </div>
    <div id="pageInheritance">
        <h3>Page Inheritance</h3>       
We've seen with server-side iframes how the DBS supports embedding page components from one page into others.  Another for of code reuse is "Page Inheritance," where an 
        extending page inherits and modifies a base page.  The syntax:<br />

<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="1" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">html</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li style="background: #f3f3f3"><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">head</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li>    <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">meta</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">name</span><span style="background:#ffffff;color:#0000ff">=&quot;inherits&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">content</span><span style="background:#ffffff;color:#0000ff">=&quot;form1.tsp.html&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#0000ff">/&gt;</span></li>
<li style="background: #f3f3f3">    <span style="background:#ffffff;color:#000000"></span><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">title</span><span style="background:#ffffff;color:#0000ff">&gt;</span><span style="background:#ffffff;color:#000000">Inherit Test</span><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">title</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
<li><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">head</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>

        <br />
        will take the contents of the base page, "form1.tsp.html" and merge the contents of the page itself on top of the base page.  
        The merging will follow rules similar to how <a href="http://msdn.microsoft.com/en-us/library/dd465326(v=vs.110).aspx">Microsoft's XML Transformation</a> works, 
        and the merging will be done on the server-side (with a notable exception detailed later).  A typical merging node will look as follows:
<br /><br />
        
<div style="border: #000080 1px solid; color: #000; font-family: 'Courier New', Courier, Monospace; font-size: 10pt">
<div style="background: #000080; color: #fff; font-family: Verdana, Tahoma, Arial, sans-serif; font-weight: bold; padding: 2px 5px">Code Snippet</div>
<div style="background: #fff; max-height: 300px; overflow: auto">
<ol start="8" style="background: #ffffff; margin: 0; padding: 0 0 0 5px;">
<li><span style="background:#ffffff;color:#0000ff">&lt;</span><span style="background:#ffffff;color:#800000">span</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">id</span><span style="background:#ffffff;color:#0000ff">=&quot;msg&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-xmatch</span><span style="background:#ffffff;color:#0000ff">=&quot;id&quot;</span><span style="background:#ffffff;color:#000000"> </span><span style="background:#ffffff;color:#ff0000">data-xmerge</span><span style="background:#ffffff;color:#0000ff">=&quot;Replace&quot;&gt;</span><span style="background:#ffffff;color:#000000">Here is a new message</span><span style="background:#ffffff;color:#0000ff">&lt;/</span><span style="background:#ffffff;color:#800000">span</span><span style="background:#ffffff;color:#0000ff">&gt;</span></li>
</ol>
</div>
</div>

        <br />
        Merging will follow these rules:

        <ul>
            <li>Matching: Nodes in the extending page will be matched with nodes in the base page as follows:
                
        
                <ul>
                <li>
                    Matching will start at the root level and get applied recursively.  In the absense of special attributes, matching will be based on the tag name.  
                        If there is only one tag with the same tag name at one level of the DOM tree, and the base page has the same single tag name at that level, then they match.  So based on these rules,  
                        &lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; will typically easily match between the two documents.

                </li>
                <li>
                    Where there is more than one tag with the same tag name at the same level of the DOM tree, in either the base or the extending document, matching will need to be done with the help of a locator attribute.&nbsp; Locator attributes are either <em>data-match</em> or <em>data-xmatch-cssSelect</em></li>
                <li>
                    The data-xmatch attribute indicates one or more other attributes (comma delimited) to find an exact match on all the values of the attributes.
                </li>
                
                <li>
                    A more flexible matching attribute is the xmatch/cssSelect attribute <em>data-xmatch-cssSelect</em>, which searches the base document for a single node matching the CSS selector criteria.
                </li>
                <li>
                    If no match is found, but the <em>data-xmerge </em>attribute requires the existence of a match (see below), an error will be thrown.  
                </li>
                </ul>
            </li>
            <li>Transforming:  Nothing from the extending document will be added to the output coming from the base document, unless a matching node contains the                  
                            data-xmerge attribute.  This attribute can have the following values:
                        
                    <ul>
                        <li>Append -- appends to the end of the matching parent node</li>
                        <li>Insert after -- requires that the previous sibling node in the extending document matches a node in the base document</li>
                        <li>Insert before -- requires that the following sibling node in the extending document matches a node in the base document</li>
                        <li>Remove (requires matching node)</li>
                        <li>RemoveChildren (requires matching node)</li>
                        <li>Replace (requires matching node)</li>
                        <li>ReplaceAttributes (requires matching node)</li>
                    </ul>
            </li>
                    
                
            
        </ul>
        <br /><br />
        The meta tag with name &quot;inherits&quot; will normally cause the merging to be done on the server-side.&nbsp; However, there is an important special case where the meta tag will be ignored -- and that is in the case where the page is being requested from a client-side form submission, which will be described below.&nbsp; As we shall see, in this case, the merging will be done on the client-side, following the same rules as above.&nbsp; [This will allow for browsers which have JavaScript disabled to gracefully provide similar results, though with performance likely to be degraded.e Form later]</h4>
   </div>
    
    <div id="forms">
        <h3>Forms</h3>
    </div>

</body>
</html>
