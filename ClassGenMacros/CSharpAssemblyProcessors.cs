using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Reflection;
//using System.Runtime.InteropServices.WindowsRuntime;
using System.Text;

namespace ClassGenMacros
{

    public static class AssemblyHelper
    {
        public static List<FileContentsGeneratedFromAssembly> ToFileContents<TTypeProcessor>(this Assembly assembly, Func<Type, bool> test, string namespaceKeyWord, string fileExt) where TTypeProcessor : BaseTypeProcessorAttribute
        {
            string interfaces = FileContentsGeneratedFromAssembly.ProcessToString<TTypeProcessor>(assembly, test, namespaceKeyWord);
            var ret = new List<FileContentsGeneratedFromAssembly>();
            var interf = new FileContentsGeneratedFromAssembly
            {
                FileContent = interfaces,
                FileName = assembly.FullName.SubstringBefore(",") + fileExt,
            };
            ret.Add(interf);
            return ret;
        }
    }
  
    #region Interface -> Class
    public class AssemblyProcessorToProcessInterfaces : IProcessAssemblyToFileFragments
    {
        public List<FileContentsGeneratedFromAssembly> Process(Assembly assembly)
        {
            return assembly.ToFileContents<AutoGenerateDefaultCSharpImplementationAttribute>(type => type.IsInterface, "namespace", ".defaultImpl.cs");
            //string interfaces = FileContentsGeneratedFromAssembly.ProcessToString(assembly, type=>type.IsInterface, "namespace");
            //var ret = new List<FileContentsGeneratedFromAssembly>();
            //var interf = new FileContentsGeneratedFromAssembly
            //{
            //    FileContent = interfaces,
            //    FileName = assembly.FullName.SubstringBefore(",") + ".defaultImpl.cs",
            //};
            //ret.Add(interf);
            //return ret;
        }
    }
    #endregion

    #region Base Class + Interface -> Extended Class
    public class AssemblyProcessorToExtendCSharpClassFromInterface : IProcessAssemblyToFileFragments
    {
        public List<FileContentsGeneratedFromAssembly> Process(Assembly assembly)
        {
            return assembly.ToFileContents<AutoGeneratePropertiesAttribute>(type => type.IsClass && type.GetCustAttrib<AutoGeneratePropertiesAttribute>() != null, "namespace", ".classExtender.cs");
        }
    }
    #endregion

    #region Class -> Static Extension Class
    public class AssemblyProcessorToCreateCSharpExtensionLibraryFromTypes : IProcessAssemblyToFileFragments
    {
        public List<FileContentsGeneratedFromAssembly> Process(Assembly assembly)
        {
            return assembly.ToFileContents<AutoGenerateExtensionMethodsAttribute>(type => type.IsClass && type.GetCustAttrib<AutoGenerateExtensionMethodsAttribute>() != null, "namespace", ".extensionLibs.cs");
        }
    }
    #endregion

    #region NamingClass -> NameClass
    public class AssemblyProcessorToCreateCSharpNamingClasses : IProcessAssemblyToFileFragments
    {
        public List<FileContentsGeneratedFromAssembly> Process(Assembly assembly)
        {
            return assembly.ToFileContents<AutoGenerateNamingClassAttribute>(type => type.IsClass && type.GetCustAttrib<AutoGenerateNamingClassAttribute>() != null, "namespace", ".extensionLibs.cs");
        }
    }
    #endregion
}
